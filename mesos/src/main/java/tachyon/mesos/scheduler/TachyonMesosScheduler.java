package tachyon.mesos.scheduler;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;
import org.apache.mesos.*;
import org.apache.mesos.Protos;

import tachyon.Constants;

/**
 * The Tachyon Mesos Framework Scheduler.
 *
 * See: http://mesos.apache.org
 */
public class TachyonMesosScheduler implements Scheduler {
  private static final Logger LOG = Logger.getLogger(Constants.LOGGER_TYPE);

  // Scheduler state

  protected Set<String> workers = new HashSet<String>();
  protected int tasksCreated = 0;
  protected int tasksRunning = 0;

  // Utility methods

  protected Protos.TaskInfo makeTachyonTask(
      String id,
      boolean format,
      Protos.Offer offer) {
    return null; // TODO
  }

  protected boolean isTerminal(Protos.TaskState state) {
    return state == Protos.TaskState.TASK_FINISHED ||
           state == Protos.TaskState.TASK_FAILED ||
           state == Protos.TaskState.TASK_KILLED ||
           state == Protos.TaskState.TASK_LOST;
  }

  // Callbacks inherited from org.apache.mesos.Scheduler

  /**
   * Invoked when the scheduler successfully registers with a Mesos
   * master. A unique ID (generated by the master) used for
   * distinguishing this framework from others and MasterInfo
   * with the IP and port of the current master are provided as arguments.
   *
   * @param driver      The scheduler driver that was registered.
   * @param frameworkId The framework ID generated by the master.
   * @param masterInfo  Info about the current master, including IP and port.
   *
   * @see SchedulerDriver
   * @see FrameworkID
   * @see MasterInfo
   */
  @Override
  public void registered(
      SchedulerDriver driver,
      Protos.FrameworkID frameworkId,
      Protos.MasterInfo masterInfo) {
    LOG.info(String.format(
      "Registered with Mesos master [%s:%d]",
      masterInfo.getHostname(),
      masterInfo.getPort()
    ));
  }

  /**
   * Invoked when the scheduler re-registers with a newly elected Mesos master.
   * This is only called when the scheduler has previously been registered.
   * MasterInfo containing the updated information about the elected master
   * is provided as an argument.
   *
   * @param driver      The driver that was re-registered.
   * @param masterInfo  The updated information about the elected master.
   *
   * @see SchedulerDriver
   * @see MasterInfo
   */
  @Override
  public void reregistered(
      SchedulerDriver driver,
      Protos.MasterInfo masterInfo) {
    LOG.info(String.format(
      "Reregistered with Mesos master [%s:%d]",
      masterInfo.getHostname(),
      masterInfo.getPort()
    ));
  }

  /**
   * Invoked when resources have been offered to this framework. A
   * single offer will only contain resources from a single slave.
   * Resources associated with an offer will not be re-offered to
   * _this_ framework until either (a) this framework has rejected
   * those resources (see {@link SchedulerDriver#launchTasks}) or (b)
   * those resources have been rescinded (see {@link Scheduler#offerRescinded}).
   * Note that resources may be concurrently offered to more than one
   * framework at a time (depending on the allocator being used). In
   * that case, the first framework to launch tasks using those
   * resources will be able to use them while the other frameworks
   * will have those resources rescinded (or if a framework has
   * already launched tasks with those resources then those tasks will
   * fail with a TASK_LOST status and a message saying as much).
   *
   * @param driver  The driver that was used to run this scheduler.
   * @param offers  The resources offered to this framework.
   *
   * @see SchedulerDriver
   * @see Offer
   */
  @Override
  public void resourceOffers(
      SchedulerDriver driver,
      List<Protos.Offer> offers) {

    for (Protos.Offer offer : offers) {
      LOG.info(String.format("Got resource offer [%s]", offer));

      LinkedList<Protos.TaskInfo> tasks = new LinkedList<Protos.TaskInfo>();
      List<Protos.OfferID> offerIdList = new LinkedList<Protos.OfferID>();
      offerIdList.add(offer.getId());

      if (!workers.contains(offer.getHostname())) {
        String worker = offer.getHostname();
        workers.add(worker);
        tasks.add(makeTachyonTask("" + tasksCreated, true, offer));
        tasksCreated++;

        LOG.info(String.format("Launching Tachyon Worker on [%s]", worker));

        driver.launchTasks(offerIdList, tasks);
      }
      else {
        driver.declineOffer(offer.getId());
      }
    }
  }

  /**
   * Invoked when an offer is no longer valid (e.g., the slave was
   * lost or another framework used resources in the offer). If for
   * whatever reason an offer is never rescinded (e.g., dropped
   * message, failing over framework, etc.), a framwork that attempts
   * to launch tasks using an invalid offer will receive TASK_LOST
   * status updats for those tasks (see {@link #resourceOffers}).
   *
   * @param driver  The driver that was used to run this scheduler.
   * @param offerId The ID of the offer that was rescinded.
   *
   * @see SchedulerDriver
   * @see OfferID
   */
  @Override
  public void offerRescinded(
      SchedulerDriver driver,
      Protos.OfferID offerId) {
    LOG.info(String.format(
      "Offer [%s] has been rescinded",
      offerId.getValue()
    ));
  }

  /**
   * Invoked when the status of a task has changed (e.g., a slave is
   * lost and so the task is lost, a task finishes and an executor
   * sends a status update saying so, etc). Note that returning from
   * this callback _acknowledges_ receipt of this status update! If
   * for whatever reason the scheduler aborts during this callback (or
   * the process exits) another status update will be delivered (note,
   * however, that this is currently not true if the slave sending the
   * status update is lost/fails during that time).
   *
   * @param driver The driver that was used to run this scheduler.
   * @param status The status update, which includes the task ID and status.
   *
   * @see SchedulerDriver
   * @see TaskStatus
   */
  @Override
  public void statusUpdate(
      SchedulerDriver driver,
      Protos.TaskStatus taskStatus) {
    Protos.TaskState state = taskStatus.getState();

    LOG.info(String.format(
      "Task [%s] is in state [%s]",
      taskStatus.getTaskId().getValue(),
      state
    ));

    if (state == Protos.TaskState.TASK_RUNNING)
      tasksRunning++;
    else if (isTerminal(state))
      tasksRunning = Math.max(0, tasksRunning - 1);
  }

  /**
   * Invoked when an executor sends a message. These messages are best
   * effort; do not expect a framework message to be retransmitted in
   * any reliable fashion.
   *
   * @param driver      The driver that received the message.
   * @param executorId  The ID of the executor that sent the message.
   * @param slaveId     The ID of the slave that launched the executor.
   * @param data        The message payload.
   *
   * @see SchedulerDriver
   * @see ExecutorID
   * @see SlaveID
   */
  @Override
  public void frameworkMessage(
      SchedulerDriver driver,
      Protos.ExecutorID executorId,
      Protos.SlaveID slaveId,
      byte[] data) {
    LOG.info(String.format(
      "Received a framework message from [%s]",
      executorId.getValue()
    ));
  }

  /**
   * Invoked when the scheduler becomes "disconnected" from the master
   * (e.g., the master fails and another is taking over).
   *
   * @param driver  The driver that was used to run this scheduler.
   *
   * @see SchedulerDriver
   */
  @Override
  public void disconnected(SchedulerDriver driver) {
    LOG.info("Disconnected from the Mesos master.");
  }

  /**
   * Invoked when a slave has been determined unreachable (e.g.,
   * machine failure, network partition). Most frameworks will need to
   * reschedule any tasks launched on this slave on a new slave.
   *
   * @param driver  The driver that was used to run this scheduler.
   * @param slaveId The ID of the slave that was lost.
   *
   * @see SchedulerDriver
   * @see SlaveID
   */
  @Override
  public void slaveLost(
      SchedulerDriver driver,
      Protos.SlaveID slaveId) {
    LOG.info(String.format(
      "SLAVE LOST: [%s]",
      slaveId.getValue()
    ));
  }

  /**
   * Invoked when an executor has exited/terminated. Note that any
   * tasks running will have TASK_LOST status updates automagically
   * generated.
   *
   * @param driver      The driver that was used to run this scheduler.
   * @param executorId  The ID of the executor that was lost.
   * @param slaveId     The ID of the slave that launched the executor.
   * @param status      The exit status of the executor.
   *
   * @see SchedulerDriver
   * @see ExecutorID
   * @see SlaveID
   * @see Status
   */
  @Override
  public void executorLost(
      SchedulerDriver driver,
      Protos.ExecutorID executorId,
      Protos.SlaveID slaveId,
      int status) {
    LOG.info(String.format("EXECUTOR LOST: [%s]", executorId.getValue()));
  }

  /**
   * Invoked when there is an unrecoverable error in the scheduler or
   * driver. The driver will be aborted BEFORE invoking this callback.
   *
   * @param driver  The driver that was used to run this scheduler.
   * @param message The error message.
   *
   * @see SchedulerDriver
   */
  @Override
  public void error(SchedulerDriver driver, String msg) {
    LOG.warn(String.format("ERROR: [%s]", msg));
  }

}
